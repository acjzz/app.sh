#!/bin/bash

set -e
set -u

APPSH_HOME=$(cd $(dirname "$0")/.. && pwd)

. $APPSH_HOME/lib/common
# HEADER END

key_expr="[a-zA-Z][_a-zA-Z0-9]*"

files=()
arg_files=()
declare -a arg_files
name=""
use_default_files=yes

while getopts "f:Dn:" opt
do
  case $opt in
    f)
      file="$OPTARG"
      if [[ $file == "-" ]]
      then
        file=/dev/stdin
      fi
      arg_files+=($file)
      ;;
    D)
      use_default_files=no
      ;;
    n)
      name=$OPTARG
      ;;
    \?)
      usage "Invalid option: $OPTARG"
      ;;
  esac
done

if [[ $use_default_files == yes ]]
then
  app_home=${APP_HOME-.}

  files+=(${APPSH_DEFAULT_CONFIG-$APPSH_HOME/lib/default-config})

  if [ -r "$HOME/.appconfig" ]
  then
    files+=("$HOME/.appconfig")
  fi

  if [ -r "$app_home/.app/config" ]
  then
    files+=("$app_home/.app/config")
  fi
fi

# Even if arg_files is declared above, the files+= statement will fail
# with "unbound" variable. bash-4.2.45.
if [ "${#arg_files[@]}" -gt 0 ]
then
  files+=("${arg_files[@]}")
fi

# TODO: find config files in the paths above $file's paths and perhaps
# /etc/appsh/config.

if [ -z "$name" ]
then
  filter="s,^[ ]*\($key_expr\.$key_expr\)[ ]*=[ ]*\(.*\)$,\1=\2,p"
else
  filter="s,^\($name\)=\(.*\),\1=\2,p"
fi

debug "Using files:" "${files[@]}"

# The awk script makes sure each key only appears once. The first one wins

(for ((idx=${#files[@]}-1 ; idx>=0 ; idx-- )); do cat ${files[idx]}; done) | \
  sed -n -e "$filter" | \
  awk -F = ' (!($1 in a)){a[$1]; print }' | \
  sort
